// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `dev.deminearchiver.device_info_ffi.DeviceInfo$BuildVersion`
class DeviceInfo$BuildVersion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<DeviceInfo$BuildVersion> $type;

  @jni$_.internal
  DeviceInfo$BuildVersion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/deminearchiver/device_info_ffi/DeviceInfo$BuildVersion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DeviceInfo$BuildVersion?> nullableType =
      $DeviceInfo$BuildVersion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DeviceInfo$BuildVersion> type =
      $DeviceInfo$BuildVersion$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Integer;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Integer integer, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DeviceInfo$BuildVersion(
    jni$_.JString? string,
    jni$_.JInteger? integer,
    jni$_.JString? string1,
    jni$_.JString string2,
    jni$_.JString string3,
    jni$_.JString string4,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$integer = integer?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2.reference;
    final _$string3 = string3.reference;
    final _$string4 = string4.reference;
    return DeviceInfo$BuildVersion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$integer.pointer,
        _$string1.pointer,
        _$string2.pointer,
        _$string3.pointer,
        _$string4.pointer,
        i,
      ).reference,
    );
  }

  static final _id_getBaseOS = _class.instanceMethodId(
    r'getBaseOS',
    r'()Ljava/lang/String;',
  );

  static final _getBaseOS =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getBaseOS()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getBaseOS() {
    return _getBaseOS(
      reference.pointer,
      _id_getBaseOS as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getPreviewSdkInt = _class.instanceMethodId(
    r'getPreviewSdkInt',
    r'()Ljava/lang/Integer;',
  );

  static final _getPreviewSdkInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Integer getPreviewSdkInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? getPreviewSdkInt() {
    return _getPreviewSdkInt(
      reference.pointer,
      _id_getPreviewSdkInt as jni$_.JMethodIDPtr,
    ).object<jni$_.JInteger?>(const jni$_.$JInteger$NullableType$());
  }

  static final _id_getSecurityPatch = _class.instanceMethodId(
    r'getSecurityPatch',
    r'()Ljava/lang/String;',
  );

  static final _getSecurityPatch =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getSecurityPatch()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSecurityPatch() {
    return _getSecurityPatch(
      reference.pointer,
      _id_getSecurityPatch as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getCodename = _class.instanceMethodId(
    r'getCodename',
    r'()Ljava/lang/String;',
  );

  static final _getCodename =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getCodename()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getCodename() {
    return _getCodename(
      reference.pointer,
      _id_getCodename as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getIncremental = _class.instanceMethodId(
    r'getIncremental',
    r'()Ljava/lang/String;',
  );

  static final _getIncremental =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getIncremental()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getIncremental() {
    return _getIncremental(
      reference.pointer,
      _id_getIncremental as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getRelease = _class.instanceMethodId(
    r'getRelease',
    r'()Ljava/lang/String;',
  );

  static final _getRelease =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getRelease()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getRelease() {
    return _getRelease(
      reference.pointer,
      _id_getRelease as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getSdkInt = _class.instanceMethodId(r'getSdkInt', r'()I');

  static final _getSdkInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int getSdkInt()`
  int getSdkInt() {
    return _getSdkInt(
      reference.pointer,
      _id_getSdkInt as jni$_.JMethodIDPtr,
    ).integer;
  }
}

final class $DeviceInfo$BuildVersion$NullableType$
    extends jni$_.JType<DeviceInfo$BuildVersion?> {
  @jni$_.internal
  const $DeviceInfo$BuildVersion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/deminearchiver/device_info_ffi/DeviceInfo$BuildVersion;';

  @jni$_.internal
  @core$_.override
  DeviceInfo$BuildVersion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : DeviceInfo$BuildVersion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DeviceInfo$BuildVersion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DeviceInfo$BuildVersion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeviceInfo$BuildVersion$NullableType$) &&
        other is $DeviceInfo$BuildVersion$NullableType$;
  }
}

final class $DeviceInfo$BuildVersion$Type$
    extends jni$_.JType<DeviceInfo$BuildVersion> {
  @jni$_.internal
  const $DeviceInfo$BuildVersion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/deminearchiver/device_info_ffi/DeviceInfo$BuildVersion;';

  @jni$_.internal
  @core$_.override
  DeviceInfo$BuildVersion fromReference(jni$_.JReference reference) =>
      DeviceInfo$BuildVersion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DeviceInfo$BuildVersion?> get nullableType =>
      const $DeviceInfo$BuildVersion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DeviceInfo$BuildVersion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeviceInfo$BuildVersion$Type$) &&
        other is $DeviceInfo$BuildVersion$Type$;
  }
}

/// from: `dev.deminearchiver.device_info_ffi.DeviceInfo`
class DeviceInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<DeviceInfo> $type;

  @jni$_.internal
  DeviceInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/deminearchiver/device_info_ffi/DeviceInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DeviceInfo?> nullableType =
      $DeviceInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DeviceInfo> type = $DeviceInfo$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/lang/String;Ljava/lang/String;ZLjava/util/List;JJLdev/deminearchiver/device_info_ffi/DeviceInfo$BuildVersion;ZJJ)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int64,
                    jni$_.Int64,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int64,
                    jni$_.Int64,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6, java.lang.String string7, java.lang.String string8, java.lang.String string9, java.lang.String string10, java.lang.String string11, java.lang.String string12, java.util.List<java.lang.String> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.String> list2, java.lang.String string13, java.lang.String string14, boolean z, java.util.List<java.lang.String> list3, long j, long j1, dev.deminearchiver.device_info_ffi.DeviceInfo$BuildVersion buildVersion, boolean z1, long j2, long j3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DeviceInfo(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JString string2,
    jni$_.JString string3,
    jni$_.JString string4,
    jni$_.JString string5,
    jni$_.JString string6,
    jni$_.JString string7,
    jni$_.JString string8,
    jni$_.JString string9,
    jni$_.JString string10,
    jni$_.JString string11,
    jni$_.JString? string12,
    jni$_.JList<jni$_.JString>? list,
    jni$_.JList<jni$_.JString>? list1,
    jni$_.JList<jni$_.JString>? list2,
    jni$_.JString string13,
    jni$_.JString string14,
    bool z,
    jni$_.JList<jni$_.JString> list3,
    int j,
    int j1,
    DeviceInfo$BuildVersion buildVersion,
    bool z1,
    int j2,
    int j3,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$string2 = string2.reference;
    final _$string3 = string3.reference;
    final _$string4 = string4.reference;
    final _$string5 = string5.reference;
    final _$string6 = string6.reference;
    final _$string7 = string7.reference;
    final _$string8 = string8.reference;
    final _$string9 = string9.reference;
    final _$string10 = string10.reference;
    final _$string11 = string11.reference;
    final _$string12 = string12?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$string13 = string13.reference;
    final _$string14 = string14.reference;
    final _$list3 = list3.reference;
    final _$buildVersion = buildVersion.reference;
    return DeviceInfo.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
        _$string3.pointer,
        _$string4.pointer,
        _$string5.pointer,
        _$string6.pointer,
        _$string7.pointer,
        _$string8.pointer,
        _$string9.pointer,
        _$string10.pointer,
        _$string11.pointer,
        _$string12.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$string13.pointer,
        _$string14.pointer,
        z ? 1 : 0,
        _$list3.pointer,
        j,
        j1,
        _$buildVersion.pointer,
        z1 ? 1 : 0,
        j2,
        j3,
      ).reference,
    );
  }

  static final _id_getBoard = _class.instanceMethodId(
    r'getBoard',
    r'()Ljava/lang/String;',
  );

  static final _getBoard =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getBoard()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getBoard() {
    return _getBoard(
      reference.pointer,
      _id_getBoard as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getBootloader = _class.instanceMethodId(
    r'getBootloader',
    r'()Ljava/lang/String;',
  );

  static final _getBootloader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getBootloader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getBootloader() {
    return _getBootloader(
      reference.pointer,
      _id_getBootloader as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getBrand = _class.instanceMethodId(
    r'getBrand',
    r'()Ljava/lang/String;',
  );

  static final _getBrand =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getBrand()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getBrand() {
    return _getBrand(
      reference.pointer,
      _id_getBrand as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getDevice = _class.instanceMethodId(
    r'getDevice',
    r'()Ljava/lang/String;',
  );

  static final _getDevice =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getDevice()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getDevice() {
    return _getDevice(
      reference.pointer,
      _id_getDevice as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getDisplay = _class.instanceMethodId(
    r'getDisplay',
    r'()Ljava/lang/String;',
  );

  static final _getDisplay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getDisplay()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getDisplay() {
    return _getDisplay(
      reference.pointer,
      _id_getDisplay as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/lang/String;',
  );

  static final _getFingerprint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getFingerprint() {
    return _getFingerprint(
      reference.pointer,
      _id_getFingerprint as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getHardware = _class.instanceMethodId(
    r'getHardware',
    r'()Ljava/lang/String;',
  );

  static final _getHardware =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getHardware()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getHardware() {
    return _getHardware(
      reference.pointer,
      _id_getHardware as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getHost = _class.instanceMethodId(
    r'getHost',
    r'()Ljava/lang/String;',
  );

  static final _getHost =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getHost()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getHost() {
    return _getHost(
      reference.pointer,
      _id_getHost as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(
      reference.pointer,
      _id_getId as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getManufacturer = _class.instanceMethodId(
    r'getManufacturer',
    r'()Ljava/lang/String;',
  );

  static final _getManufacturer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getManufacturer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getManufacturer() {
    return _getManufacturer(
      reference.pointer,
      _id_getManufacturer as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getModel = _class.instanceMethodId(
    r'getModel',
    r'()Ljava/lang/String;',
  );

  static final _getModel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getModel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getModel() {
    return _getModel(
      reference.pointer,
      _id_getModel as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getProduct = _class.instanceMethodId(
    r'getProduct',
    r'()Ljava/lang/String;',
  );

  static final _getProduct =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getProduct()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getProduct() {
    return _getProduct(
      reference.pointer,
      _id_getProduct as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(
      reference.pointer,
      _id_getName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getSupported32BitAbis = _class.instanceMethodId(
    r'getSupported32BitAbis',
    r'()Ljava/util/List;',
  );

  static final _getSupported32BitAbis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getSupported32BitAbis()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString>? getSupported32BitAbis() {
    return _getSupported32BitAbis(
      reference.pointer,
      _id_getSupported32BitAbis as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>?>(
      const jni$_.$JList$NullableType$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_getSupported64BitAbis = _class.instanceMethodId(
    r'getSupported64BitAbis',
    r'()Ljava/util/List;',
  );

  static final _getSupported64BitAbis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getSupported64BitAbis()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString>? getSupported64BitAbis() {
    return _getSupported64BitAbis(
      reference.pointer,
      _id_getSupported64BitAbis as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>?>(
      const jni$_.$JList$NullableType$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_getSupportedAbis = _class.instanceMethodId(
    r'getSupportedAbis',
    r'()Ljava/util/List;',
  );

  static final _getSupportedAbis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getSupportedAbis()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString>? getSupportedAbis() {
    return _getSupportedAbis(
      reference.pointer,
      _id_getSupportedAbis as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>?>(
      const jni$_.$JList$NullableType$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_getTags = _class.instanceMethodId(
    r'getTags',
    r'()Ljava/lang/String;',
  );

  static final _getTags =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getTags()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTags() {
    return _getTags(
      reference.pointer,
      _id_getTags as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/lang/String;',
  );

  static final _getType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getType() {
    return _getType(
      reference.pointer,
      _id_getType as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_isPhysicalDevice = _class.instanceMethodId(
    r'isPhysicalDevice',
    r'()Z',
  );

  static final _isPhysicalDevice =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isPhysicalDevice()`
  bool isPhysicalDevice() {
    return _isPhysicalDevice(
      reference.pointer,
      _id_isPhysicalDevice as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getSystemFeatures = _class.instanceMethodId(
    r'getSystemFeatures',
    r'()Ljava/util/List;',
  );

  static final _getSystemFeatures =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getSystemFeatures()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> getSystemFeatures() {
    return _getSystemFeatures(
      reference.pointer,
      _id_getSystemFeatures as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>>(
      const jni$_.$JList$Type$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_getFreeDiskSize = _class.instanceMethodId(
    r'getFreeDiskSize',
    r'()J',
  );

  static final _getFreeDiskSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getFreeDiskSize()`
  int getFreeDiskSize() {
    return _getFreeDiskSize(
      reference.pointer,
      _id_getFreeDiskSize as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getTotalDiskSize = _class.instanceMethodId(
    r'getTotalDiskSize',
    r'()J',
  );

  static final _getTotalDiskSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getTotalDiskSize()`
  int getTotalDiskSize() {
    return _getTotalDiskSize(
      reference.pointer,
      _id_getTotalDiskSize as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getVersion = _class.instanceMethodId(
    r'getVersion',
    r'()Ldev/deminearchiver/device_info_ffi/DeviceInfo$BuildVersion;',
  );

  static final _getVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final dev.deminearchiver.device_info_ffi.DeviceInfo$BuildVersion getVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  DeviceInfo$BuildVersion getVersion() {
    return _getVersion(
      reference.pointer,
      _id_getVersion as jni$_.JMethodIDPtr,
    ).object<DeviceInfo$BuildVersion>(const $DeviceInfo$BuildVersion$Type$());
  }

  static final _id_isLowRamDevice = _class.instanceMethodId(
    r'isLowRamDevice',
    r'()Z',
  );

  static final _isLowRamDevice =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isLowRamDevice()`
  bool isLowRamDevice() {
    return _isLowRamDevice(
      reference.pointer,
      _id_isLowRamDevice as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getPhysicalRamSize = _class.instanceMethodId(
    r'getPhysicalRamSize',
    r'()J',
  );

  static final _getPhysicalRamSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getPhysicalRamSize()`
  int getPhysicalRamSize() {
    return _getPhysicalRamSize(
      reference.pointer,
      _id_getPhysicalRamSize as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getAvailableRamSize = _class.instanceMethodId(
    r'getAvailableRamSize',
    r'()J',
  );

  static final _getAvailableRamSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getAvailableRamSize()`
  int getAvailableRamSize() {
    return _getAvailableRamSize(
      reference.pointer,
      _id_getAvailableRamSize as jni$_.JMethodIDPtr,
    ).long;
  }
}

final class $DeviceInfo$NullableType$ extends jni$_.JType<DeviceInfo?> {
  @jni$_.internal
  const $DeviceInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/deminearchiver/device_info_ffi/DeviceInfo;';

  @jni$_.internal
  @core$_.override
  DeviceInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DeviceInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DeviceInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DeviceInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeviceInfo$NullableType$) &&
        other is $DeviceInfo$NullableType$;
  }
}

final class $DeviceInfo$Type$ extends jni$_.JType<DeviceInfo> {
  @jni$_.internal
  const $DeviceInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/deminearchiver/device_info_ffi/DeviceInfo;';

  @jni$_.internal
  @core$_.override
  DeviceInfo fromReference(jni$_.JReference reference) =>
      DeviceInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DeviceInfo?> get nullableType =>
      const $DeviceInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DeviceInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeviceInfo$Type$) &&
        other is $DeviceInfo$Type$;
  }
}

/// from: `dev.deminearchiver.device_info_ffi.DeviceInfoPlugin`
class DeviceInfoPlugin extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<DeviceInfoPlugin> $type;

  @jni$_.internal
  DeviceInfoPlugin.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'dev/deminearchiver/device_info_ffi/DeviceInfoPlugin',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DeviceInfoPlugin?> nullableType =
      $DeviceInfoPlugin$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DeviceInfoPlugin> type = $DeviceInfoPlugin$Type$();
  static final _id_INSTANCE = _class.staticFieldId(
    r'INSTANCE',
    r'Ldev/deminearchiver/device_info_ffi/DeviceInfoPlugin;',
  );

  /// from: `static public final dev.deminearchiver.device_info_ffi.DeviceInfoPlugin INSTANCE`
  /// The returned object must be released after use, by calling the [release] method.
  static DeviceInfoPlugin get INSTANCE =>
      _id_INSTANCE.get(_class, const $DeviceInfoPlugin$Type$());

  static final _id_getDeviceInfo = _class.staticMethodId(
    r'getDeviceInfo',
    r'(Landroid/content/Context;)Ldev/deminearchiver/device_info_ffi/DeviceInfo;',
  );

  static final _getDeviceInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun getDeviceInfo(context: android.content.Context): dev.deminearchiver.device_info_ffi.DeviceInfo`
  /// The returned object must be released after use, by calling the [release] method.
  static DeviceInfo getDeviceInfo(jni$_.JObject context) {
    final _$context = context.reference;
    return _getDeviceInfo(
      _class.reference.pointer,
      _id_getDeviceInfo as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<DeviceInfo>(const $DeviceInfo$Type$());
  }
}

final class $DeviceInfoPlugin$NullableType$
    extends jni$_.JType<DeviceInfoPlugin?> {
  @jni$_.internal
  const $DeviceInfoPlugin$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/deminearchiver/device_info_ffi/DeviceInfoPlugin;';

  @jni$_.internal
  @core$_.override
  DeviceInfoPlugin? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DeviceInfoPlugin.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DeviceInfoPlugin?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DeviceInfoPlugin$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeviceInfoPlugin$NullableType$) &&
        other is $DeviceInfoPlugin$NullableType$;
  }
}

final class $DeviceInfoPlugin$Type$ extends jni$_.JType<DeviceInfoPlugin> {
  @jni$_.internal
  const $DeviceInfoPlugin$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/deminearchiver/device_info_ffi/DeviceInfoPlugin;';

  @jni$_.internal
  @core$_.override
  DeviceInfoPlugin fromReference(jni$_.JReference reference) =>
      DeviceInfoPlugin.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<DeviceInfoPlugin?> get nullableType =>
      const $DeviceInfoPlugin$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DeviceInfoPlugin$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeviceInfoPlugin$Type$) &&
        other is $DeviceInfoPlugin$Type$;
  }
}
