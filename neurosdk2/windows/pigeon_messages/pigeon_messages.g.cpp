// Autogenerated from Pigeon (v26.1.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "pigeon_messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace pigeon_neuro_api {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

FlutterError CreateConnectionError(const std::string channel_name) {
  return FlutterError(
      "channel-error",
      "Unable to establish connection on channel: '" + channel_name + "'.",
      EncodableValue(""));
}

// FCallibriStimulatorMAState

FCallibriStimulatorMAState::FCallibriStimulatorMAState(
  const FCallibriStimulatorState& stimulator_state,
  const FCallibriStimulatorState& ma_state)
 : stimulator_state_(stimulator_state),
    ma_state_(ma_state) {}

const FCallibriStimulatorState& FCallibriStimulatorMAState::stimulator_state() const {
  return stimulator_state_;
}

void FCallibriStimulatorMAState::set_stimulator_state(const FCallibriStimulatorState& value_arg) {
  stimulator_state_ = value_arg;
}


const FCallibriStimulatorState& FCallibriStimulatorMAState::ma_state() const {
  return ma_state_;
}

void FCallibriStimulatorMAState::set_ma_state(const FCallibriStimulatorState& value_arg) {
  ma_state_ = value_arg;
}


EncodableList FCallibriStimulatorMAState::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(CustomEncodableValue(stimulator_state_));
  list.push_back(CustomEncodableValue(ma_state_));
  return list;
}

FCallibriStimulatorMAState FCallibriStimulatorMAState::FromEncodableList(const EncodableList& list) {
  FCallibriStimulatorMAState decoded(
    std::any_cast<const FCallibriStimulatorState&>(std::get<CustomEncodableValue>(list[0])),
    std::any_cast<const FCallibriStimulatorState&>(std::get<CustomEncodableValue>(list[1])));
  return decoded;
}

// FCallibriStimulationParams

FCallibriStimulationParams::FCallibriStimulationParams(
  int64_t current,
  int64_t pulse_width,
  int64_t frequency,
  int64_t stimulus_duration)
 : current_(current),
    pulse_width_(pulse_width),
    frequency_(frequency),
    stimulus_duration_(stimulus_duration) {}

int64_t FCallibriStimulationParams::current() const {
  return current_;
}

void FCallibriStimulationParams::set_current(int64_t value_arg) {
  current_ = value_arg;
}


int64_t FCallibriStimulationParams::pulse_width() const {
  return pulse_width_;
}

void FCallibriStimulationParams::set_pulse_width(int64_t value_arg) {
  pulse_width_ = value_arg;
}


int64_t FCallibriStimulationParams::frequency() const {
  return frequency_;
}

void FCallibriStimulationParams::set_frequency(int64_t value_arg) {
  frequency_ = value_arg;
}


int64_t FCallibriStimulationParams::stimulus_duration() const {
  return stimulus_duration_;
}

void FCallibriStimulationParams::set_stimulus_duration(int64_t value_arg) {
  stimulus_duration_ = value_arg;
}


EncodableList FCallibriStimulationParams::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(current_));
  list.push_back(EncodableValue(pulse_width_));
  list.push_back(EncodableValue(frequency_));
  list.push_back(EncodableValue(stimulus_duration_));
  return list;
}

FCallibriStimulationParams FCallibriStimulationParams::FromEncodableList(const EncodableList& list) {
  FCallibriStimulationParams decoded(
    std::get<int64_t>(list[0]),
    std::get<int64_t>(list[1]),
    std::get<int64_t>(list[2]),
    std::get<int64_t>(list[3]));
  return decoded;
}

// FCallibriMotionAssistantParams

FCallibriMotionAssistantParams::FCallibriMotionAssistantParams(
  int64_t gyro_start,
  int64_t gyro_stop,
  const FCallibriMotionAssistantLimb& limb,
  int64_t min_pause_ms)
 : gyro_start_(gyro_start),
    gyro_stop_(gyro_stop),
    limb_(limb),
    min_pause_ms_(min_pause_ms) {}

int64_t FCallibriMotionAssistantParams::gyro_start() const {
  return gyro_start_;
}

void FCallibriMotionAssistantParams::set_gyro_start(int64_t value_arg) {
  gyro_start_ = value_arg;
}


int64_t FCallibriMotionAssistantParams::gyro_stop() const {
  return gyro_stop_;
}

void FCallibriMotionAssistantParams::set_gyro_stop(int64_t value_arg) {
  gyro_stop_ = value_arg;
}


const FCallibriMotionAssistantLimb& FCallibriMotionAssistantParams::limb() const {
  return limb_;
}

void FCallibriMotionAssistantParams::set_limb(const FCallibriMotionAssistantLimb& value_arg) {
  limb_ = value_arg;
}


int64_t FCallibriMotionAssistantParams::min_pause_ms() const {
  return min_pause_ms_;
}

void FCallibriMotionAssistantParams::set_min_pause_ms(int64_t value_arg) {
  min_pause_ms_ = value_arg;
}


EncodableList FCallibriMotionAssistantParams::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(gyro_start_));
  list.push_back(EncodableValue(gyro_stop_));
  list.push_back(CustomEncodableValue(limb_));
  list.push_back(EncodableValue(min_pause_ms_));
  return list;
}

FCallibriMotionAssistantParams FCallibriMotionAssistantParams::FromEncodableList(const EncodableList& list) {
  FCallibriMotionAssistantParams decoded(
    std::get<int64_t>(list[0]),
    std::get<int64_t>(list[1]),
    std::any_cast<const FCallibriMotionAssistantLimb&>(std::get<CustomEncodableValue>(list[2])),
    std::get<int64_t>(list[3]));
  return decoded;
}

// FCallibriMotionCounterParam

FCallibriMotionCounterParam::FCallibriMotionCounterParam(
  int64_t insense_threshold_m_g,
  int64_t insense_threshold_sample)
 : insense_threshold_m_g_(insense_threshold_m_g),
    insense_threshold_sample_(insense_threshold_sample) {}

int64_t FCallibriMotionCounterParam::insense_threshold_m_g() const {
  return insense_threshold_m_g_;
}

void FCallibriMotionCounterParam::set_insense_threshold_m_g(int64_t value_arg) {
  insense_threshold_m_g_ = value_arg;
}


int64_t FCallibriMotionCounterParam::insense_threshold_sample() const {
  return insense_threshold_sample_;
}

void FCallibriMotionCounterParam::set_insense_threshold_sample(int64_t value_arg) {
  insense_threshold_sample_ = value_arg;
}


EncodableList FCallibriMotionCounterParam::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(insense_threshold_m_g_));
  list.push_back(EncodableValue(insense_threshold_sample_));
  return list;
}

FCallibriMotionCounterParam FCallibriMotionCounterParam::FromEncodableList(const EncodableList& list) {
  FCallibriMotionCounterParam decoded(
    std::get<int64_t>(list[0]),
    std::get<int64_t>(list[1]));
  return decoded;
}

// FSensorInfo

FSensorInfo::FSensorInfo(
  const std::string& name,
  const std::string& address,
  const std::string& serial_number,
  bool pairing_required,
  int64_t sens_model,
  const FSensorFamily& sens_family,
  int64_t rssi)
 : name_(name),
    address_(address),
    serial_number_(serial_number),
    pairing_required_(pairing_required),
    sens_model_(sens_model),
    sens_family_(sens_family),
    rssi_(rssi) {}

const std::string& FSensorInfo::name() const {
  return name_;
}

void FSensorInfo::set_name(std::string_view value_arg) {
  name_ = value_arg;
}


const std::string& FSensorInfo::address() const {
  return address_;
}

void FSensorInfo::set_address(std::string_view value_arg) {
  address_ = value_arg;
}


const std::string& FSensorInfo::serial_number() const {
  return serial_number_;
}

void FSensorInfo::set_serial_number(std::string_view value_arg) {
  serial_number_ = value_arg;
}


bool FSensorInfo::pairing_required() const {
  return pairing_required_;
}

void FSensorInfo::set_pairing_required(bool value_arg) {
  pairing_required_ = value_arg;
}


int64_t FSensorInfo::sens_model() const {
  return sens_model_;
}

void FSensorInfo::set_sens_model(int64_t value_arg) {
  sens_model_ = value_arg;
}


const FSensorFamily& FSensorInfo::sens_family() const {
  return sens_family_;
}

void FSensorInfo::set_sens_family(const FSensorFamily& value_arg) {
  sens_family_ = value_arg;
}


int64_t FSensorInfo::rssi() const {
  return rssi_;
}

void FSensorInfo::set_rssi(int64_t value_arg) {
  rssi_ = value_arg;
}


EncodableList FSensorInfo::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(EncodableValue(name_));
  list.push_back(EncodableValue(address_));
  list.push_back(EncodableValue(serial_number_));
  list.push_back(EncodableValue(pairing_required_));
  list.push_back(EncodableValue(sens_model_));
  list.push_back(CustomEncodableValue(sens_family_));
  list.push_back(EncodableValue(rssi_));
  return list;
}

FSensorInfo FSensorInfo::FromEncodableList(const EncodableList& list) {
  FSensorInfo decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]),
    std::get<bool>(list[3]),
    std::get<int64_t>(list[4]),
    std::any_cast<const FSensorFamily&>(std::get<CustomEncodableValue>(list[5])),
    std::get<int64_t>(list[6]));
  return decoded;
}

// FParameterInfo

FParameterInfo::FParameterInfo(
  const FSensorParameter& param,
  const FSensorParamAccess& param_access)
 : param_(param),
    param_access_(param_access) {}

const FSensorParameter& FParameterInfo::param() const {
  return param_;
}

void FParameterInfo::set_param(const FSensorParameter& value_arg) {
  param_ = value_arg;
}


const FSensorParamAccess& FParameterInfo::param_access() const {
  return param_access_;
}

void FParameterInfo::set_param_access(const FSensorParamAccess& value_arg) {
  param_access_ = value_arg;
}


EncodableList FParameterInfo::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(CustomEncodableValue(param_));
  list.push_back(CustomEncodableValue(param_access_));
  return list;
}

FParameterInfo FParameterInfo::FromEncodableList(const EncodableList& list) {
  FParameterInfo decoded(
    std::any_cast<const FSensorParameter&>(std::get<CustomEncodableValue>(list[0])),
    std::any_cast<const FSensorParamAccess&>(std::get<CustomEncodableValue>(list[1])));
  return decoded;
}

// FSensorVersion

FSensorVersion::FSensorVersion(
  int64_t fw_major,
  int64_t fw_minor,
  int64_t fw_patch,
  int64_t hw_major,
  int64_t hw_minor,
  int64_t hw_patch,
  int64_t ext_major)
 : fw_major_(fw_major),
    fw_minor_(fw_minor),
    fw_patch_(fw_patch),
    hw_major_(hw_major),
    hw_minor_(hw_minor),
    hw_patch_(hw_patch),
    ext_major_(ext_major) {}

int64_t FSensorVersion::fw_major() const {
  return fw_major_;
}

void FSensorVersion::set_fw_major(int64_t value_arg) {
  fw_major_ = value_arg;
}


int64_t FSensorVersion::fw_minor() const {
  return fw_minor_;
}

void FSensorVersion::set_fw_minor(int64_t value_arg) {
  fw_minor_ = value_arg;
}


int64_t FSensorVersion::fw_patch() const {
  return fw_patch_;
}

void FSensorVersion::set_fw_patch(int64_t value_arg) {
  fw_patch_ = value_arg;
}


int64_t FSensorVersion::hw_major() const {
  return hw_major_;
}

void FSensorVersion::set_hw_major(int64_t value_arg) {
  hw_major_ = value_arg;
}


int64_t FSensorVersion::hw_minor() const {
  return hw_minor_;
}

void FSensorVersion::set_hw_minor(int64_t value_arg) {
  hw_minor_ = value_arg;
}


int64_t FSensorVersion::hw_patch() const {
  return hw_patch_;
}

void FSensorVersion::set_hw_patch(int64_t value_arg) {
  hw_patch_ = value_arg;
}


int64_t FSensorVersion::ext_major() const {
  return ext_major_;
}

void FSensorVersion::set_ext_major(int64_t value_arg) {
  ext_major_ = value_arg;
}


EncodableList FSensorVersion::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(EncodableValue(fw_major_));
  list.push_back(EncodableValue(fw_minor_));
  list.push_back(EncodableValue(fw_patch_));
  list.push_back(EncodableValue(hw_major_));
  list.push_back(EncodableValue(hw_minor_));
  list.push_back(EncodableValue(hw_patch_));
  list.push_back(EncodableValue(ext_major_));
  return list;
}

FSensorVersion FSensorVersion::FromEncodableList(const EncodableList& list) {
  FSensorVersion decoded(
    std::get<int64_t>(list[0]),
    std::get<int64_t>(list[1]),
    std::get<int64_t>(list[2]),
    std::get<int64_t>(list[3]),
    std::get<int64_t>(list[4]),
    std::get<int64_t>(list[5]),
    std::get<int64_t>(list[6]));
  return decoded;
}

// FEEGChannelInfo

FEEGChannelInfo::FEEGChannelInfo(
  const FEEGChannelId& id,
  const FEEGChannelType& ch_type,
  const std::string& name,
  int64_t num)
 : id_(id),
    ch_type_(ch_type),
    name_(name),
    num_(num) {}

const FEEGChannelId& FEEGChannelInfo::id() const {
  return id_;
}

void FEEGChannelInfo::set_id(const FEEGChannelId& value_arg) {
  id_ = value_arg;
}


const FEEGChannelType& FEEGChannelInfo::ch_type() const {
  return ch_type_;
}

void FEEGChannelInfo::set_ch_type(const FEEGChannelType& value_arg) {
  ch_type_ = value_arg;
}


const std::string& FEEGChannelInfo::name() const {
  return name_;
}

void FEEGChannelInfo::set_name(std::string_view value_arg) {
  name_ = value_arg;
}


int64_t FEEGChannelInfo::num() const {
  return num_;
}

void FEEGChannelInfo::set_num(int64_t value_arg) {
  num_ = value_arg;
}


EncodableList FEEGChannelInfo::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(CustomEncodableValue(id_));
  list.push_back(CustomEncodableValue(ch_type_));
  list.push_back(EncodableValue(name_));
  list.push_back(EncodableValue(num_));
  return list;
}

FEEGChannelInfo FEEGChannelInfo::FromEncodableList(const EncodableList& list) {
  FEEGChannelInfo decoded(
    std::any_cast<const FEEGChannelId&>(std::get<CustomEncodableValue>(list[0])),
    std::any_cast<const FEEGChannelType&>(std::get<CustomEncodableValue>(list[1])),
    std::get<std::string>(list[2]),
    std::get<int64_t>(list[3]));
  return decoded;
}

// BrainBit2AmplifierParamNative

BrainBit2AmplifierParamNative::BrainBit2AmplifierParamNative(
  const EncodableList& ch_signal_mode,
  const EncodableList& ch_resist_use,
  const EncodableList& ch_gain,
  const FGenCurrent& current)
 : ch_signal_mode_(ch_signal_mode),
    ch_resist_use_(ch_resist_use),
    ch_gain_(ch_gain),
    current_(current) {}

const EncodableList& BrainBit2AmplifierParamNative::ch_signal_mode() const {
  return ch_signal_mode_;
}

void BrainBit2AmplifierParamNative::set_ch_signal_mode(const EncodableList& value_arg) {
  ch_signal_mode_ = value_arg;
}


const EncodableList& BrainBit2AmplifierParamNative::ch_resist_use() const {
  return ch_resist_use_;
}

void BrainBit2AmplifierParamNative::set_ch_resist_use(const EncodableList& value_arg) {
  ch_resist_use_ = value_arg;
}


const EncodableList& BrainBit2AmplifierParamNative::ch_gain() const {
  return ch_gain_;
}

void BrainBit2AmplifierParamNative::set_ch_gain(const EncodableList& value_arg) {
  ch_gain_ = value_arg;
}


const FGenCurrent& BrainBit2AmplifierParamNative::current() const {
  return current_;
}

void BrainBit2AmplifierParamNative::set_current(const FGenCurrent& value_arg) {
  current_ = value_arg;
}


EncodableList BrainBit2AmplifierParamNative::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(ch_signal_mode_));
  list.push_back(EncodableValue(ch_resist_use_));
  list.push_back(EncodableValue(ch_gain_));
  list.push_back(CustomEncodableValue(current_));
  return list;
}

BrainBit2AmplifierParamNative BrainBit2AmplifierParamNative::FromEncodableList(const EncodableList& list) {
  BrainBit2AmplifierParamNative decoded(
    std::get<EncodableList>(list[0]),
    std::get<EncodableList>(list[1]),
    std::get<EncodableList>(list[2]),
    std::any_cast<const FGenCurrent&>(std::get<CustomEncodableValue>(list[3])));
  return decoded;
}


PigeonInternalCodecSerializer::PigeonInternalCodecSerializer() {}

EncodableValue PigeonInternalCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 129: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FCallibriColorType>(enum_arg_value));
      }
    case 130: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FCallibriElectrodeState>(enum_arg_value));
      }
    case 131: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorFilter>(enum_arg_value));
      }
    case 132: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<CallibriSignalType>(enum_arg_value));
      }
    case 133: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FCallibriStimulatorState>(enum_arg_value));
      }
    case 134: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FCallibriMotionAssistantLimb>(enum_arg_value));
      }
    case 135: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorADCInput>(enum_arg_value));
      }
    case 136: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorCommand>(enum_arg_value));
      }
    case 137: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorDataOffset>(enum_arg_value));
      }
    case 138: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorExternalSwitchInput>(enum_arg_value));
      }
    case 139: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorFamily>(enum_arg_value));
      }
    case 140: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorFeature>(enum_arg_value));
      }
    case 141: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorFirmwareMode>(enum_arg_value));
      }
    case 142: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorGain>(enum_arg_value));
      }
    case 143: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorParameter>(enum_arg_value));
      }
    case 144: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorParamAccess>(enum_arg_value));
      }
    case 145: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorSamplingFrequency>(enum_arg_value));
      }
    case 146: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorState>(enum_arg_value));
      }
    case 147: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorAccelerometerSensitivity>(enum_arg_value));
      }
    case 148: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorGyroscopeSensitivity>(enum_arg_value));
      }
    case 149: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FSensorAmpMode>(enum_arg_value));
      }
    case 150: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FIrAmplitude>(enum_arg_value));
      }
    case 151: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FRedAmplitude>(enum_arg_value));
      }
    case 152: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FEEGChannelType>(enum_arg_value));
      }
    case 153: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FEEGChannelId>(enum_arg_value));
      }
    case 154: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FBrainBit2ChannelMode>(enum_arg_value));
      }
    case 155: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<FGenCurrent>(enum_arg_value));
      }
    case 156: {
        return CustomEncodableValue(FCallibriStimulatorMAState::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 157: {
        return CustomEncodableValue(FCallibriStimulationParams::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 158: {
        return CustomEncodableValue(FCallibriMotionAssistantParams::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 159: {
        return CustomEncodableValue(FCallibriMotionCounterParam::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 160: {
        return CustomEncodableValue(FSensorInfo::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 161: {
        return CustomEncodableValue(FParameterInfo::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 162: {
        return CustomEncodableValue(FSensorVersion::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 163: {
        return CustomEncodableValue(FEEGChannelInfo::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 164: {
        return CustomEncodableValue(BrainBit2AmplifierParamNative::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
    }
}

void PigeonInternalCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(FCallibriColorType)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FCallibriColorType>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FCallibriElectrodeState)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FCallibriElectrodeState>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorFilter)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorFilter>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(CallibriSignalType)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<CallibriSignalType>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FCallibriStimulatorState)) {
      stream->WriteByte(133);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FCallibriStimulatorState>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FCallibriMotionAssistantLimb)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FCallibriMotionAssistantLimb>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorADCInput)) {
      stream->WriteByte(135);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorADCInput>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorCommand)) {
      stream->WriteByte(136);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorCommand>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorDataOffset)) {
      stream->WriteByte(137);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorDataOffset>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorExternalSwitchInput)) {
      stream->WriteByte(138);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorExternalSwitchInput>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorFamily)) {
      stream->WriteByte(139);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorFamily>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorFeature)) {
      stream->WriteByte(140);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorFeature>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorFirmwareMode)) {
      stream->WriteByte(141);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorFirmwareMode>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorGain)) {
      stream->WriteByte(142);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorGain>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorParameter)) {
      stream->WriteByte(143);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorParameter>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorParamAccess)) {
      stream->WriteByte(144);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorParamAccess>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorSamplingFrequency)) {
      stream->WriteByte(145);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorSamplingFrequency>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorState)) {
      stream->WriteByte(146);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorState>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorAccelerometerSensitivity)) {
      stream->WriteByte(147);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorAccelerometerSensitivity>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorGyroscopeSensitivity)) {
      stream->WriteByte(148);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorGyroscopeSensitivity>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorAmpMode)) {
      stream->WriteByte(149);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FSensorAmpMode>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FIrAmplitude)) {
      stream->WriteByte(150);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FIrAmplitude>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FRedAmplitude)) {
      stream->WriteByte(151);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FRedAmplitude>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FEEGChannelType)) {
      stream->WriteByte(152);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FEEGChannelType>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FEEGChannelId)) {
      stream->WriteByte(153);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FEEGChannelId>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FBrainBit2ChannelMode)) {
      stream->WriteByte(154);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FBrainBit2ChannelMode>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FGenCurrent)) {
      stream->WriteByte(155);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<FGenCurrent>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(FCallibriStimulatorMAState)) {
      stream->WriteByte(156);
      WriteValue(EncodableValue(std::any_cast<FCallibriStimulatorMAState>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(FCallibriStimulationParams)) {
      stream->WriteByte(157);
      WriteValue(EncodableValue(std::any_cast<FCallibriStimulationParams>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(FCallibriMotionAssistantParams)) {
      stream->WriteByte(158);
      WriteValue(EncodableValue(std::any_cast<FCallibriMotionAssistantParams>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(FCallibriMotionCounterParam)) {
      stream->WriteByte(159);
      WriteValue(EncodableValue(std::any_cast<FCallibriMotionCounterParam>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorInfo)) {
      stream->WriteByte(160);
      WriteValue(EncodableValue(std::any_cast<FSensorInfo>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(FParameterInfo)) {
      stream->WriteByte(161);
      WriteValue(EncodableValue(std::any_cast<FParameterInfo>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(FSensorVersion)) {
      stream->WriteByte(162);
      WriteValue(EncodableValue(std::any_cast<FSensorVersion>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(FEEGChannelInfo)) {
      stream->WriteByte(163);
      WriteValue(EncodableValue(std::any_cast<FEEGChannelInfo>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(BrainBit2AmplifierParamNative)) {
      stream->WriteByte(164);
      WriteValue(EncodableValue(std::any_cast<BrainBit2AmplifierParamNative>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by NeuroApi.
const flutter::StandardMessageCodec& NeuroApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&PigeonInternalCodecSerializer::GetInstance());
}

// Sets up an instance of `NeuroApi` to handle messages through the `binary_messenger`.
void NeuroApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  NeuroApi* api) {
  NeuroApi::SetUp(binary_messenger, api, "");
}

void NeuroApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  NeuroApi* api,
  const std::string& message_channel_suffix) {
  const std::string prepended_suffix = message_channel_suffix.length() > 0 ? std::string(".") + message_channel_suffix : "";
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.createScanner" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_filters_arg = args.at(0);
          if (encodable_filters_arg.IsNull()) {
            reply(WrapError("filters_arg unexpectedly null."));
            return;
          }
          const auto& filters_arg = std::get<EncodableList>(encodable_filters_arg);
          api->CreateScanner(filters_arg, [reply](ErrorOr<std::string>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.closeScanner" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          api->CloseScanner(guid_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.startScan" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          api->StartScan(guid_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.stopScan" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          api->StopScan(guid_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.createSensor" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_sensor_info_arg = args.at(1);
          if (encodable_sensor_info_arg.IsNull()) {
            reply(WrapError("sensor_info_arg unexpectedly null."));
            return;
          }
          const auto& sensor_info_arg = std::any_cast<const FSensorInfo&>(std::get<CustomEncodableValue>(encodable_sensor_info_arg));
          api->CreateSensor(guid_arg, sensor_info_arg, [reply](ErrorOr<std::string>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSensors" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<EncodableList> output = api->GetSensors(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.closeSensor" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          api->CloseSensor(guid_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.connectSensor" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          api->ConnectSensor(guid_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.disconnectSensor" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          api->DisconnectSensor(guid_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.supportedFeatures" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<EncodableList> output = api->SupportedFeatures(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.isSupportedFeature" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_feature_arg = args.at(1);
          if (encodable_feature_arg.IsNull()) {
            reply(WrapError("feature_arg unexpectedly null."));
            return;
          }
          const auto& feature_arg = std::any_cast<const FSensorFeature&>(std::get<CustomEncodableValue>(encodable_feature_arg));
          ErrorOr<bool> output = api->IsSupportedFeature(guid_arg, feature_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.supportedCommands" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<EncodableList> output = api->SupportedCommands(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.isSupportedCommand" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_command_arg = args.at(1);
          if (encodable_command_arg.IsNull()) {
            reply(WrapError("command_arg unexpectedly null."));
            return;
          }
          const auto& command_arg = std::any_cast<const FSensorCommand&>(std::get<CustomEncodableValue>(encodable_command_arg));
          ErrorOr<bool> output = api->IsSupportedCommand(guid_arg, command_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.supportedParameters" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<EncodableList> output = api->SupportedParameters(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.isSupportedParameter" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_parameter_arg = args.at(1);
          if (encodable_parameter_arg.IsNull()) {
            reply(WrapError("parameter_arg unexpectedly null."));
            return;
          }
          const auto& parameter_arg = std::any_cast<const FSensorParameter&>(std::get<CustomEncodableValue>(encodable_parameter_arg));
          ErrorOr<bool> output = api->IsSupportedParameter(guid_arg, parameter_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.execCommand" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_command_arg = args.at(1);
          if (encodable_command_arg.IsNull()) {
            reply(WrapError("command_arg unexpectedly null."));
            return;
          }
          const auto& command_arg = std::any_cast<const FSensorCommand&>(std::get<CustomEncodableValue>(encodable_command_arg));
          api->ExecCommand(guid_arg, command_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getName" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<std::string> output = api->GetName(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setName" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_name_arg = args.at(1);
          if (encodable_name_arg.IsNull()) {
            reply(WrapError("name_arg unexpectedly null."));
            return;
          }
          const auto& name_arg = std::get<std::string>(encodable_name_arg);
          std::optional<FlutterError> output = api->SetName(guid_arg, name_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getState" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorState> output = api->GetState(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getAddress" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<std::string> output = api->GetAddress(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSerialNumber" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<std::string> output = api->GetSerialNumber(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setSerialNumber" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_sn_arg = args.at(1);
          if (encodable_sn_arg.IsNull()) {
            reply(WrapError("sn_arg unexpectedly null."));
            return;
          }
          const auto& sn_arg = std::get<std::string>(encodable_sn_arg);
          std::optional<FlutterError> output = api->SetSerialNumber(guid_arg, sn_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getBattPower" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<int64_t> output = api->GetBattPower(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSamplingFrequency" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorSamplingFrequency> output = api->GetSamplingFrequency(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getGain" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorGain> output = api->GetGain(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getDataOffset" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorDataOffset> output = api->GetDataOffset(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getFirmwareMode" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorFirmwareMode> output = api->GetFirmwareMode(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getVersion" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorVersion> output = api->GetVersion(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getChannelsCount" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<int64_t> output = api->GetChannelsCount(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSensFamily" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorFamily> output = api->GetSensFamily(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getAmpMode" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorAmpMode> output = api->GetAmpMode(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSamplingFrequencyResist" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorSamplingFrequency> output = api->GetSamplingFrequencyResist(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSamplingFrequencyFPG" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorSamplingFrequency> output = api->GetSamplingFrequencyFPG(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getIrAmplitude" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FIrAmplitude> output = api->GetIrAmplitude(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setIrAmplitude" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_amp_arg = args.at(1);
          if (encodable_amp_arg.IsNull()) {
            reply(WrapError("amp_arg unexpectedly null."));
            return;
          }
          const auto& amp_arg = std::any_cast<const FIrAmplitude&>(std::get<CustomEncodableValue>(encodable_amp_arg));
          std::optional<FlutterError> output = api->SetIrAmplitude(guid_arg, amp_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getRedAmplitude" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FRedAmplitude> output = api->GetRedAmplitude(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setRedAmplitude" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_amp_arg = args.at(1);
          if (encodable_amp_arg.IsNull()) {
            reply(WrapError("amp_arg unexpectedly null."));
            return;
          }
          const auto& amp_arg = std::any_cast<const FRedAmplitude&>(std::get<CustomEncodableValue>(encodable_amp_arg));
          std::optional<FlutterError> output = api->SetRedAmplitude(guid_arg, amp_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.pingNeuroSmart" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_marker_arg = args.at(1);
          if (encodable_marker_arg.IsNull()) {
            reply(WrapError("marker_arg unexpectedly null."));
            return;
          }
          const int64_t marker_arg = encodable_marker_arg.LongValue();
          api->PingNeuroSmart(guid_arg, marker_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setGain" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_gain_arg = args.at(1);
          if (encodable_gain_arg.IsNull()) {
            reply(WrapError("gain_arg unexpectedly null."));
            return;
          }
          const auto& gain_arg = std::any_cast<const FSensorGain&>(std::get<CustomEncodableValue>(encodable_gain_arg));
          std::optional<FlutterError> output = api->SetGain(guid_arg, gain_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.isSupportedFilter" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_filter_arg = args.at(1);
          if (encodable_filter_arg.IsNull()) {
            reply(WrapError("filter_arg unexpectedly null."));
            return;
          }
          const auto& filter_arg = std::any_cast<const FSensorFilter&>(std::get<CustomEncodableValue>(encodable_filter_arg));
          ErrorOr<bool> output = api->IsSupportedFilter(guid_arg, filter_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSupportedFilters" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<EncodableList> output = api->GetSupportedFilters(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getHardwareFilters" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<EncodableList> output = api->GetHardwareFilters(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setHardwareFilters" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_filters_arg = args.at(1);
          if (encodable_filters_arg.IsNull()) {
            reply(WrapError("filters_arg unexpectedly null."));
            return;
          }
          const auto& filters_arg = std::get<EncodableList>(encodable_filters_arg);
          std::optional<FlutterError> output = api->SetHardwareFilters(guid_arg, filters_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setFirmwareMode" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_mode_arg = args.at(1);
          if (encodable_mode_arg.IsNull()) {
            reply(WrapError("mode_arg unexpectedly null."));
            return;
          }
          const auto& mode_arg = std::any_cast<const FSensorFirmwareMode&>(std::get<CustomEncodableValue>(encodable_mode_arg));
          std::optional<FlutterError> output = api->SetFirmwareMode(guid_arg, mode_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setSamplingFrequency" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_sf_arg = args.at(1);
          if (encodable_sf_arg.IsNull()) {
            reply(WrapError("sf_arg unexpectedly null."));
            return;
          }
          const auto& sf_arg = std::any_cast<const FSensorSamplingFrequency&>(std::get<CustomEncodableValue>(encodable_sf_arg));
          std::optional<FlutterError> output = api->SetSamplingFrequency(guid_arg, sf_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setDataOffset" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_offset_arg = args.at(1);
          if (encodable_offset_arg.IsNull()) {
            reply(WrapError("offset_arg unexpectedly null."));
            return;
          }
          const auto& offset_arg = std::any_cast<const FSensorDataOffset&>(std::get<CustomEncodableValue>(encodable_offset_arg));
          std::optional<FlutterError> output = api->SetDataOffset(guid_arg, offset_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getExtSwInput" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorExternalSwitchInput> output = api->GetExtSwInput(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setExtSwInput" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_ext_sw_inp_arg = args.at(1);
          if (encodable_ext_sw_inp_arg.IsNull()) {
            reply(WrapError("ext_sw_inp_arg unexpectedly null."));
            return;
          }
          const auto& ext_sw_inp_arg = std::any_cast<const FSensorExternalSwitchInput&>(std::get<CustomEncodableValue>(encodable_ext_sw_inp_arg));
          std::optional<FlutterError> output = api->SetExtSwInput(guid_arg, ext_sw_inp_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getADCInput" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorADCInput> output = api->GetADCInput(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setADCInput" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_adc_inp_arg = args.at(1);
          if (encodable_adc_inp_arg.IsNull()) {
            reply(WrapError("adc_inp_arg unexpectedly null."));
            return;
          }
          const auto& adc_inp_arg = std::any_cast<const FSensorADCInput&>(std::get<CustomEncodableValue>(encodable_adc_inp_arg));
          std::optional<FlutterError> output = api->SetADCInput(guid_arg, adc_inp_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getStimulatorMAState" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FCallibriStimulatorMAState> output = api->GetStimulatorMAState(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getStimulatorParam" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FCallibriStimulationParams> output = api->GetStimulatorParam(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setStimulatorParam" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_param_arg = args.at(1);
          if (encodable_param_arg.IsNull()) {
            reply(WrapError("param_arg unexpectedly null."));
            return;
          }
          const auto& param_arg = std::any_cast<const FCallibriStimulationParams&>(std::get<CustomEncodableValue>(encodable_param_arg));
          std::optional<FlutterError> output = api->SetStimulatorParam(guid_arg, param_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getMotionAssistantParam" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FCallibriMotionAssistantParams> output = api->GetMotionAssistantParam(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setMotionAssistantParam" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_param_arg = args.at(1);
          if (encodable_param_arg.IsNull()) {
            reply(WrapError("param_arg unexpectedly null."));
            return;
          }
          const auto& param_arg = std::any_cast<const FCallibriMotionAssistantParams&>(std::get<CustomEncodableValue>(encodable_param_arg));
          std::optional<FlutterError> output = api->SetMotionAssistantParam(guid_arg, param_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getMotionCounterParam" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FCallibriMotionCounterParam> output = api->GetMotionCounterParam(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setMotionCounterParam" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_param_arg = args.at(1);
          if (encodable_param_arg.IsNull()) {
            reply(WrapError("param_arg unexpectedly null."));
            return;
          }
          const auto& param_arg = std::any_cast<const FCallibriMotionCounterParam&>(std::get<CustomEncodableValue>(encodable_param_arg));
          std::optional<FlutterError> output = api->SetMotionCounterParam(guid_arg, param_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getMotionCounter" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<int64_t> output = api->GetMotionCounter(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getColor" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FCallibriColorType> output = api->GetColor(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getMEMSCalibrateState" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<bool> output = api->GetMEMSCalibrateState(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSamplingFrequencyResp" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorSamplingFrequency> output = api->GetSamplingFrequencyResp(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSamplingFrequencyEnvelope" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorSamplingFrequency> output = api->GetSamplingFrequencyEnvelope(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSignalType" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<CallibriSignalType> output = api->GetSignalType(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setSignalType" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_type_arg = args.at(1);
          if (encodable_type_arg.IsNull()) {
            reply(WrapError("type_arg unexpectedly null."));
            return;
          }
          const auto& type_arg = std::any_cast<const CallibriSignalType&>(std::get<CustomEncodableValue>(encodable_type_arg));
          std::optional<FlutterError> output = api->SetSignalType(guid_arg, type_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getElectrodeState" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FCallibriElectrodeState> output = api->GetElectrodeState(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getAccSens" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorAccelerometerSensitivity> output = api->GetAccSens(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setAccSens" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_acc_sens_arg = args.at(1);
          if (encodable_acc_sens_arg.IsNull()) {
            reply(WrapError("acc_sens_arg unexpectedly null."));
            return;
          }
          const auto& acc_sens_arg = std::any_cast<const FSensorAccelerometerSensitivity&>(std::get<CustomEncodableValue>(encodable_acc_sens_arg));
          std::optional<FlutterError> output = api->SetAccSens(guid_arg, acc_sens_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getGyroSens" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorGyroscopeSensitivity> output = api->GetGyroSens(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setGyroSens" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_gyro_sens_arg = args.at(1);
          if (encodable_gyro_sens_arg.IsNull()) {
            reply(WrapError("gyro_sens_arg unexpectedly null."));
            return;
          }
          const auto& gyro_sens_arg = std::any_cast<const FSensorGyroscopeSensitivity&>(std::get<CustomEncodableValue>(encodable_gyro_sens_arg));
          std::optional<FlutterError> output = api->SetGyroSens(guid_arg, gyro_sens_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSamplingFrequencyMEMS" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<FSensorSamplingFrequency> output = api->GetSamplingFrequencyMEMS(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getSupportedChannels" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<EncodableList> output = api->GetSupportedChannels(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.getAmplifierParamBB2" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          ErrorOr<BrainBit2AmplifierParamNative> output = api->GetAmplifierParamBB2(guid_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pigeon_neuro_api_package.NeuroApi.setAmplifierParamBB2" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_guid_arg = args.at(0);
          if (encodable_guid_arg.IsNull()) {
            reply(WrapError("guid_arg unexpectedly null."));
            return;
          }
          const auto& guid_arg = std::get<std::string>(encodable_guid_arg);
          const auto& encodable_param_arg = args.at(1);
          if (encodable_param_arg.IsNull()) {
            reply(WrapError("param_arg unexpectedly null."));
            return;
          }
          const auto& param_arg = std::any_cast<const BrainBit2AmplifierParamNative&>(std::get<CustomEncodableValue>(encodable_param_arg));
          std::optional<FlutterError> output = api->SetAmplifierParamBB2(guid_arg, param_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue NeuroApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue NeuroApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

}  // namespace pigeon_neuro_api
